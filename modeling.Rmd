---
title: "Modeling_Katrina"
author: "Katrina Truebebach"
date: "March 18, 2019"
output: pdf_document
---

```{r}
rm(list = ls())
```

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(ggplot2)
library(tidyverse)
library(stringr)
library(lubridate)
library(modelr)
library(tis)
```

## Load cleaned data

```{r load}
load(file = '~/DS5110/data/proj_cleaned_dta.RData')
```

# Fit Model with Genre Variables vs Real Revenue

## Step Wise Selection
End model includes (in order of steps): 'Adventure', 'Action', 'Family', 'Mystery', 'Documentary', 'Drama', 'History', 'Romance'  
  
This model selection by and large makes sense. All included variables are significant at some level.  
However, according to Qiang's graphs in EDA, some of the included genres do not make a real difference to real_gross. Especially History. Also, some genres that look like they would make a signficant difference are not included. For example, Animation.
  
Thoughts:  
  
* There are a few genres that define almost all of the movies (For example, almost 80% of the movies are either Adventure, Action, Romance, or Drama). Thus, the relationship between revenue and some genres can be explained by other generes. For example, 93 out of 99 Animation movies are also Family. So Animation's effect on revenue may already by captured by Family, which is included in the model.
* On the flip side, History is included even though it seems to have a negligable effect on revenue based on the EDA bar graphs. I don't have a great explanation for this other than it was close to the cutoff RMSE for being included. 53 out of 55 History movies are also Drama. So unclear why included.  
   
Also, the residuals are debatably random vs included and excluded variables in model (not sure if these are not-random enough to matter -- see graphs).  
More concerning is the fact that the residuals themselves are not Normal. See QQ-Plot (close-ish...)

```{r exmaples, eval = F}
train %>% filter(Animation == 1, Family == 1) %>% count() # 93
train %>% filter(Animation == 1) %>% count() # 99

train %>% filter(History == 1) %>% count() # 55
train %>% filter(History == 1, Drama == 1) %>% count() # 53

```

Which genres should we be using?  
Note: not using the step() function because can't fit and find RMSE on different datasets (train, valid)


```{r}
# version of train set with just genre columns to loop through 
train_genre <- train %>% select(Action, Adventure, Animation, Biography, Comedy, Crime, Documentary,
                Drama, Family, Fantasy, History, Horror, Music, Musical, Mystery,
                Romance, SciFi, Sport, Thriller, War, Western)

train <- train %>% mutate(real_gross_log = log(real_gross))
valid <- valid %>% mutate(real_gross_log = log(real_gross))

# function to automate each step of stepwise variable selection
step_wise_step <- function(genre_lst = NULL, formula = NULL) {
  # if first step
  if (length(genre_lst) == 0) {
    # rmse with each variable against real_gross
    rmse_genre <- sapply(names(train_genre), function(var) {
      rmse(lm(as.formula(str_c('real_gross_log ~', var)), data = train), data = valid)
    })
  # if > first step: exclude variables from genre_lst from data and include in model formula
  } else {
    rmse_genre <- sapply(names(train_genre %>% select(-genre_lst)), function(var) {
      rmse(lm(as.formula(str_c('real_gross_log ~', formula, ' + ', var)), 
              data = train), data = valid)
    })
  }
  # return the name and value of the genre that resulted in the lowest RMSE 
  return(rmse_genre[which.min(rmse_genre)])
}

# loop through each step wise loop
step_wise_loop <- function() {
  # list to store min RMSE from each step in 
  rmse_lst <- c()
  
  # first step: no genre_lst or formula (default values NULL)
  min_genre <- step_wise_step()
  print(names(min_genre))
  
  # add to list of genres, formula, and min RMSE list
  genre_lst <- names(min_genre)
  formula <- str_c(names(min_genre))
  rmse_lst <- c(rmse_lst, min(min_genre))
  
  # loop through until have considered every genre variable 
  for (i in seq(1:(ncol(train_genre)-1))) {
    print(i)
    # step
    min_genre <- step_wise_step(genre_lst = genre_lst, formula = formula)
    print(min_genre)
    
    # add to lists
    genre_lst <- c(genre_lst, names(min_genre))
    formula <- str_c(formula, ' + ', names(min_genre))
    rmse_lst <- c(rmse_lst, min(min_genre))
  }
  return(rmse_lst)
}

# step wise implement
# return list of all min RMSE from each step -> graph
rmse_lst <- step_wise_loop()
```

Graph RMSE vs number of variables: how many to include?  
Specify 'final' model  

```{r rmse_gr}
# graph RMSE at each step 
fit_rmse <- tibble(nvar = 1:length(rmse_lst), 
                   rmse = rmse_lst)
ggplot(fit_rmse) + geom_line(aes(x = nvar, y = rmse))+ 
  scale_x_continuous(breaks = seq(1, length(rmse_lst), by = 1))
# after var 10, decreases too small or increase 

# model based off of step wise 
# HOWEVER some of these variables are insignificant 
  # (see pvalues and graphs from Qiang's EDA where barely any difference in revenue from genre)
mod <- lm(real_gross_log ~ Adventure + Action + Family + Mystery + 
            Documentary + Drama + History + Romance, 
          data = train)

summary(mod)
rmse(mod, data = valid)

# list of these variables for future use
genre_xvar <- c('Adventure', 'Action', 'Family', 'Mystery',
                'Documentary', 'Drama', 'History', 'Romance')
```

Graph variables in and out of model against residuals. Most are fairly evenly distributed around residual. Worst is probably Western.

```{r }
# graph residuals against each variable included in the model
# most look random except Adventure
train <- train %>% 
  add_residuals(mod) %>%
  mutate_at(vars(Action, Adventure, Animation, Biography, Comedy, Crime, Documentary,
                Drama, Family, Fantasy, History, Horror, Music, Musical, Mystery,
                Romance, SciFi, Sport, Thriller, War, Western),
            funs(as.factor(.)))

lapply(genre_xvar, function(var) {
  train %>% 
    ggplot() + 
    geom_boxplot(aes_string(var, y = 'resid'))
})

# graph residuals against each genre not included in the model 
# several are questionable if random. Especially Animation.
lapply(names(train_genre %>% select(-genre_xvar)), function(var) {
  train %>% 
    ggplot() + 
    geom_boxplot(aes_string(var, y = 'resid'))
})
```

Plot QQ plot for residuals. Not normally distributed, but close-ish.

```{r qq}
# residuals themselves are NOT normally distributed 
# qq plot 
train %>% ggplot() + 
  geom_qq(aes(sample = resid))

```


## Glmnet: sparse 
Quickly try this new method from class instead of stepwise. The sparse version does give us a lot of the same variables as stepwise. Good sign!  
Can't do statistical tests, so not useful for analysis, but can use to aid justification.

```{r sparse}
library(glmnet)
 
# matrix of x and y variables
x <- as.matrix(train_genre)
y <- as.matrix(train$real_gross_log)

# glmnet process form class 
mod <- glmnet(x, y, family = 'gaussian')
plot(mod, xvar = 'lambda', label = TRUE)
mod2 <- cv.glmnet(x, y)
plot(mod2)
coef(mod2, s = 'lambda.min') # use min lambda
coef(mod2, s = 'lambda.1se') # use most sparse
```
